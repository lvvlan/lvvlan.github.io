<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.2',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="码农/猫奴/瞎烧友/伪影迷" />


<meta name="description" content="码农/猫奴/瞎烧友/伪影迷">
<meta property="og:type" content="website">
<meta property="og:title" content="lemonleon">
<meta property="og:url" content="http://lvvlan.github.io/index.html">
<meta property="og:site_name" content="lemonleon">
<meta property="og:description" content="码农/猫奴/瞎烧友/伪影迷">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lemonleon">
<meta name="twitter:description" content="码农/猫奴/瞎烧友/伪影迷">






  <link rel="canonical" href="http://lvvlan.github.io/"/>


  <title>lemonleon</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/lvvlan" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lemonleon</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">use code, change world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            标签<span class="badge">2</span>
              </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            分类<span class="badge">1</span>
              </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            归档<span class="badge">7</span>
              </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            公益 404</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/06/03/functional5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/functional5/" itemprop="url">functional5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T21:23:43+08:00">2018-06-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote>
<p>柯里化是把一个多参数函数转化为一个嵌套的一元函数的过程</p>
</blockquote>
<p>假设有一个名为add的函数</p>
<pre><code>const add = (x, y) =&gt; x + y
</code></pre><p>这是一个简单的求和函数，没有特别之处。下面是add函数的柯里化版本</p>
<pre><code>const addCurried = x =&gt; y =&gt; x + y
</code></pre><p> 可以用如下方式调用</p>
<pre><code>const addCurried(2)(2)
</code></pre><p>我们手动的把接收两个参数的add函数转化为含有嵌套的一元函数addCurried。下面展示如何把该处理过程转化为一个名为curry的方法</p>
<pre><code>const curry = function (binaryFn) {
    return function (arg1) {
        return function (arg2) {
            return binaryFn(arg1, arg2)
        }
    }
} 
</code></pre><p>现在可以通过curry函数把add函数转化为一个柯里化版本</p>
<pre><code>let autoCurriedAdd = curry(add)

autoCurriedAdd(2)(2)    // 4
</code></pre><h2 id="日志函数-应用柯里化"><a href="#日志函数-应用柯里化" class="headerlink" title="日志函数 - 应用柯里化"></a>日志函数 - 应用柯里化</h2><p>简单的loggerHelper函数</p>
<pre><code>const loggerHelper = (mode, initMsg, errMsg, lineNo) =&gt; {
    if (mode === &apos;DEBUG&apos;) {
        console.debug(initMsg, errMsg + &apos;at line: &apos; + lineNo)
    } else if (mode === &apos;ERROR&apos;) {
        console.error(initMsg, errMsg + &apos;at line: &apos; + lineNo)
    } else if (mode === &apos;WARN&apos;) {
        console.warn(initMsg, errMsg + &apos;at line: &apos; + lineNo)
    } else {
        throw &apos;Wrong mode&apos;
    }
}   
</code></pre><p>当团队中任何开发者需要向控制台打印State.js文件中的错误时，可以用以下方式使用函数</p>
<pre><code>loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;Invalid argument passed&apos;, 23)
loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;undefined argument&apos;, 223)
loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;curry function is not defined&apos;, 3)
loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;slice is not defined&apos;, 31)
</code></pre><p> 不难看出，我们在所有的调用中都重复使用了mode和initMsg，能通过柯里化的方式调用吗？答案是可以的，但是目前我们的柯里化只能处理二元函数，那么多个参数该如何柯里化呢？下面我们完善curry函数，他可以处理任何含有多个参数的函数</p>
<pre><code>let curry = (fn) =&gt; {
    if (typeof fn !== &apos;function&apos;) throw new Error(&apos;No function provided&apos;)

    return function curriedFn(...args) {
        if (args.length &lt; fn.length) {
            return function (...rest) {
                return curriedFn.apply(null, args.concat(Array.from(rest)))
            }
        }

        return fn.apply(null, args)
    }
}
</code></pre><p>回顾日志函数，下面通过curry解决前面两个重复参数的问题</p>
<pre><code>let ErrorLogger = curry(loggerHelper)(&apos;ERROR&apos;)(&apos;ERROR at State.js&apos;)  
let DebugLogger = curry(loggerHelper)(&apos;DEBUG&apos;)(&apos;DEBUG at State.js&apos;)
let WarnLogger = curry(loggerHelper)(&apos;WARN&apos;)(&apos;WARN at State.js&apos;)

// 错误
ErrorLogger(&apos;error message&apos;, 21)
// 调试
DebugLogger(&apos;debug message&apos;, 33)
// 警告
WarnLogger(&apos;warn message&apos;, 56)
</code></pre><h2 id="柯里化实战"><a href="#柯里化实战" class="headerlink" title="柯里化实战"></a>柯里化实战</h2><h3 id="在数组内容中查找数字"><a href="#在数组内容中查找数字" class="headerlink" title="在数组内容中查找数字"></a>在数组内容中查找数字</h3><p>假设我们要查找含有数字的数组内容</p>
<pre><code>let match = curry(function (exp, str) {
    return str.match(exp)
})

let hasNumber = match(/[0-9]+/)

let filter = curry(function (fn, arr) {
    return arr.filter(fn)
})   

let findNumberInArray = filter(hasNumber)

findNumberInArray([&apos;js&apos;, &apos;number1&apos;])    // [&apos;number1&apos;]
</code></pre><h3 id="求数组的平方"><a href="#求数组的平方" class="headerlink" title="求数组的平方"></a>求数组的平方</h3><pre><code>let map = curry(function (fn, arr) {
   return arr.map(fn)
})

let squareAll = map((x) =&gt; x * x)

squareAll([1, 2, 3])   //[1, 4, 9]
</code></pre><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><h3 id="偏应用"><a href="#偏应用" class="headerlink" title="偏应用"></a>偏应用</h3><p>假设我们要每10毫秒做一组操作，可以通过setTimeout函数以如下方式实现</p>
<pre><code>setTimeout(() =&gt; console.log(&apos;Do X task&apos;), 10)
setTimeout(() =&gt; console.log(&apos;Do Y task&apos;), 10)
</code></pre><p>我们为每个setTimeout函数调用都传入了10。能使用curry函数解决吗？答案是否定的，因为curry函数应用参数的处理方式是从左到右，由于我们想根据需要传递函数，将10保存为常量，所以不能以这种方式使用curry</p>
<h3 id="实现偏函数"><a href="#实现偏函数" class="headerlink" title="实现偏函数"></a>实现偏函数</h3><pre><code>const partial = function (fn, ...partialArgs) {
    let args = partialArgs
    return function (...fullArguments) {
        let arg = 0
        for (let i = 0; i &lt; args.length &amp;&amp; arg &lt; fullArguments.length; i++) {
            if (args[i] === undefined) {
                args[i] = fullArguments[arg++]
            }
            return fn.apply(null, args)
        }
    }
}
</code></pre><p>对刚刚的问题应用偏函数</p>
<pre><code>let delayTenMs = partial(setTimeout, undefined, 10)
delayTenMs(() =&gt; console.log(&apos;delay ten ms!&apos;))
</code></pre><p>另一个应用</p>
<pre><code>let parseInt2 = partial(parseInt, undefined, 2)
parseInt2(1010) // 10
</code></pre><p>但是现在有个问题，如果我们在调用一次，传入不同的参数，却始终返回上一次的结果</p>
<pre><code>parseInt2(10)   // 10
</code></pre><p>这是由于我们将引用的args直接更改造成的，接下来我们改进这个偏函数</p>
<pre><code>const partial2 = function (fn,...partialArgs){
    let args = Array.from(partialArgs)
    return function(...fullArguments) {
        let arg = 0;

        for (let i = 0; i &lt; args.length &amp;&amp; arg &lt; fullArguments.length; i++) {
            if (partialArgs[i] === undefined) {
                args[i] = fullArguments[arg++];
            }
            return fn.apply(this, args);
        }
    }
}
</code></pre><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第6章 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/05/07/functional4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/functional4/" itemprop="url">函数式编程（三）：数组的函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T08:37:22+08:00">2018-05-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的实现与forEach非常相似，区别是用一个新的数组捕获了结果</p>
<pre><code>const map = (arr, fn) =&gt; {
    let results = []
    for(let value of arr){
        results.push(fn(value))
    }
    return results
}

map([1, 2, 3], (x) =&gt; x * x)    // [1, 4, 9]
</code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><pre><code>let apressBooks = [
  {
    &quot;id&quot;: 111,
    &quot;title&quot;: &quot;C# 6.0&quot;,
    &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
    &quot;rating&quot;: [4.7],
    &quot;reviews&quot;: [{good : 4 , excellent : 12}]
  },
  {
    &quot;id&quot;: 222,
    &quot;title&quot;: &quot;Efficient Learning Machines&quot;,
    &quot;author&quot;: &quot;Rahul Khanna&quot;,
    &quot;rating&quot;: [4.5],
    &quot;reviews&quot;: []
  },
  {
    &quot;id&quot;: 333,
    &quot;title&quot;: &quot;Pro AngularJS&quot;,
    &quot;author&quot;: &quot;Adam Freeman&quot;,
    &quot;rating&quot;: [4.0],
    &quot;reviews&quot;: []
  },
  {
    &quot;id&quot;: 444,
    &quot;title&quot;: &quot;Pro ASP.NET&quot;,
    &quot;author&quot;: &quot;Adam Freeman&quot;,
    &quot;rating&quot;: [4.2],
    &quot;reviews&quot;: [{good : 14 , excellent : 12}]
  }
];  
</code></pre><p>假设我们想获取评级高于4.5的图书列表，如何完成呢？这显然不是map能解决的问题。但是我们需要一个类似map的函数，他只需要在把结果放入数组前检查一个条件。</p>
<pre><code>const filter = (arr, fn) =&gt; {
    let results = []
    for(let value of arr){
        (fn(value)) ? results.push(value) : undefined
    }
    return results
} 

filter(apressBooks, (book) =&gt; book.rating[0] &gt; 4.5)
</code></pre><p>返回值</p>
<pre><code>[{
    &quot;id&quot;: 111,
    &quot;title&quot;: &quot;C# 6.0&quot;,
    &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
    &quot;rating&quot;: [4.7],
    &quot;reviews&quot;: [{good : 4 , excellent : 12}]
  }] 
</code></pre><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><p>为了达成目标，我们经常需要连接很多函数。例如，从apressBooks中获取含有title和author对象且评级高于4.5的对象。</p>
<pre><code>map(filter(apressBooks, (book) =&gt; book.rating[0] &gt; 4.5), (book) =&gt; {
    return {title: book.title, author: book.author}
})
</code></pre><h2 id="concatAll"><a href="#concatAll" class="headerlink" title="concatAll"></a>concatAll</h2><p>下面对apressBooks稍作修改</p>
<pre><code>let apressBooks = [
  {
    name : &quot;beginners&quot;,
    bookDetails : [
      {
        &quot;id&quot;: 111,
        &quot;title&quot;: &quot;C# 6.0&quot;,
        &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
        &quot;rating&quot;: [4.7],
        &quot;reviews&quot;: [{good : 4 , excellent : 12}]
      },
      {
        &quot;id&quot;: 222,
        &quot;title&quot;: &quot;Efficient Learning Machines&quot;,
        &quot;author&quot;: &quot;Rahul Khanna&quot;,
        &quot;rating&quot;: [4.5],
        &quot;reviews&quot;: []
      }
    ]
  },
  {
      name : &quot;pro&quot;,
      bookDetails : [
      {
        &quot;id&quot;: 333,
        &quot;title&quot;: &quot;Pro AngularJS&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.0],
        &quot;reviews&quot;: []
      },
      {
        &quot;id&quot;: 444,
        &quot;title&quot;: &quot;Pro ASP.NET&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.2],
        &quot;reviews&quot;: [{good : 14 , excellent : 12}]
      }
    ]
  }
];  
</code></pre><p>现在回顾上一节的问题，获取含有title和author字段且评价高于4.5的图书。首先使用map函数</p>
<pre><code>map(apressBooks, (book) =&gt; {
    return book.bookDetails
})
</code></pre><p>返回值</p>
<pre><code>[
    [
      {
        &quot;id&quot;: 111,
        &quot;title&quot;: &quot;C# 6.0&quot;,
        &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
        &quot;rating&quot;: [4.7],
        &quot;reviews&quot;: [{good : 4 , excellent : 12}]
      },
      {
        &quot;id&quot;: 222,
        &quot;title&quot;: &quot;Efficient Learning Machines&quot;,
        &quot;author&quot;: &quot;Rahul Khanna&quot;,
        &quot;rating&quot;: [4.5],
        &quot;reviews&quot;: []
      }
    ],
    [
      {
        &quot;id&quot;: 333,
        &quot;title&quot;: &quot;Pro AngularJS&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.0],
        &quot;reviews&quot;: []
      },
      {
        &quot;id&quot;: 444,
        &quot;title&quot;: &quot;Pro ASP.NET&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.2],
        &quot;reviews&quot;: [{good : 14 , excellent : 12}]
      }
    ]
]
</code></pre><p>map函数的返回值包含了数组中的数组，因为bookDetails本身就是一个数组，如果直接传给filter将会遇到问题。concatAll函数的作用就是把所有嵌套数组连接到一个数组中。</p>
<pre><code>const concatAll = (arr) =&gt; {
    let results = []
    for(let value of arr){
        results.push.apply(results, value)
    }
    return results
}    
</code></pre><p>接下来用concatAll将嵌套数组转化为费嵌套数组</p>
<pre><code>concatAll(
    map(apressBooks, (book) =&gt; {
        return book.bookDetails
    })
)    
</code></pre><p>返回的结果将会是转化过的数组，然后可以用filter继续连接操作   </p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>有如下数组，需要求和</p>
<pre><code>let useless = [1,2,3,4,5]
</code></pre><p>reduce代码实现</p>
<pre><code>const reduce = (arr, fn, initVal) =&gt; {
    let acc

    if(initVal != undefined){
        acc = initVal
    }else{
        acc = arr[0]
    }

    if(initVal === undefined){
        for(let i=1; i&lt;arr.length; i++){
            acc = fn(acc, arr[i])
        }
    }else{
        for(let val of arr){
            acc = fn(acc, val)
        }
    }

    return [acc]
}

reduce(useless, (a, b) =&gt; a+b)  // 15
</code></pre><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip函数用于合并给定的两个数组</p>
<pre><code>const zip = (leftArr, rightArr, fn) =&gt; {
    let results = []
    for(let index = 0; index &lt; Math.min(leftArr.length, rightArr.length); index++){
        results.push(fn(leftArr[index], rightArr[index]))
    }
    return results
}

zip([1,2,3], [4,5,6], (x, y) =&gt; x + y)  // [5, 7, 9]    
</code></pre><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第5章     </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/04/15/functional3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/functional3/" itemprop="url">函数式编程（二）：高阶函数（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T22:24:25+08:00">2018-04-15</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>简言之，闭包就是一个内部函数。在另一个函数内部的函数，称为内部函数。</p>
<pre><code>function outer () {
    function inner () {}
}
</code></pre><p>这就是闭包。函数inner被称为闭包函数。</p>
<p>闭包有三个可访问的作用域</p>
<ul>
<li>在他自身声明之内声明的变量</li>
<li>对全局变量的访问</li>
<li>对外部函数变量的访问</li>
</ul>
<hr>
<pre><code>function outer () {
    function inner () {
        let a = 5
        console.log(a)
    }
    inner()
}
</code></pre><p><strong>当inner函数被调用的时候，控制台会输出5（闭包函数可以访问在他自身声明之内声明的变量）</strong></p>
<pre><code>let global = &apos;global&apos;

function outer () {
    function inner () {
        let a = 5
        console.log(global)
    }
    inner()
} 
</code></pre><p><strong>当inner函数被调用的时候，控制台会输出’global’（闭包函数可以访问全局变量）</strong></p>
<pre><code>let global = &apos;global&apos;

function outer () {
    let out = &apos;out&apos;
    function inner () {
        let a = 5
        console.log(out)
    }
    inner()
} 
</code></pre><p><strong>当inner函数被调用的时候，控制台会输出’out’</strong>    </p>
<h3 id="记住闭包生成的位置"><a href="#记住闭包生成的位置" class="headerlink" title="记住闭包生成的位置"></a>记住闭包生成的位置</h3><p>如下代码</p>
<pre><code>let fn = (arg) =&gt; {
    let outer = &apos;Visible&apos;
    let innerFn = () =&gt; {
        console.log(outer)
        console.log(arg)
    }

    return innerFn
}
</code></pre><p>innerFn对于fn来说，是一个闭包函数，并且fn被调用后返回了innerFn。</p>
<pre><code>let closureFn = fn(5)
closureFn() // Visible; 5   
</code></pre><p>fn被调用时，返回了innerFn，当innerFn被返回时，JavaScript执行引擎视innerFn为一个闭包，如上一小节所说，闭包有三个作用域层级。这三个作用域层级（arg，outer值将被设置到inner的作用域层级中）在innerFn返回时都被设置了！返回函数的引用存储在了closureFn中。如此，当closureFn通过作用域链被调用时就记住了arg、outer的值。  </p>
<h3 id="回顾sortBy函数"><a href="#回顾sortBy函数" class="headerlink" title="回顾sortBy函数"></a>回顾sortBy函数</h3><p>快速回顾一下上一篇中定义和使用的sortBy函数</p>
<pre><code>const sortBy = (property) =&gt; {
    return (a, b) =&gt; {
        let result = (a[property] &lt; b[property] ? -1 : (a[property] &gt; b[property]) ? 1 : 0)

        return result
    }
}
</code></pre><p>当以如下方式调用sortBy函数</p>
<pre><code>sortBy(&apos;firstname&apos;)
</code></pre><p>sortBy函数返回了一个接受两个参数的新函数</p>
<pre><code>(a, b) =&gt; (/* 实现 */)
</code></pre><p>这时返回的函数就能够访问property参数，所以就可以根据传入的property值写对应的逻辑</p>
<h2 id="真实的高阶函数"><a href="#真实的高阶函数" class="headerlink" title="真实的高阶函数"></a>真实的高阶函数</h2><h3 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h3><blockquote>
<p>tap函数是一个简单的函数，他将接受一个value并返回一个包含value的闭包函数，该函数将被执行</p>
</blockquote>
<pre><code>const tap = (value) =&gt; (fn) =&gt; (
    typeof(fn) === &apos;function&apos; &amp;&amp; fn(value),
    console.log(value)
)

tap(&apos;fun&apos;)((it) =&gt; console.log(&apos;vaule is: &apos;, it))
// value is  fun
// fun
</code></pre><h3 id="unary"><a href="#unary" class="headerlink" title="unary"></a>unary</h3><blockquote>
<p>unary接受一个给定多个参数的函数，并把它转换为一个只接受一个参数的函数</p>
</blockquote>
<p>有数组[‘1’, ‘2’, ‘3’]，我期望能够将数组中的每一项改为number，我们可以利用数组的map方法</p>
<pre><code>[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt)
// [1, NaN, NaN]
</code></pre><p>然而返回的并不是我们所期望，map函数参数中传入的函数接收两个参数，第一个是数组中的每一项，第二个该项的索引。parseInt函数接收两个参数，第一个是将要转化的字符串，第二个按照几进制转换，默认10进制。由此可见，当进行到数组的第二项，parseInt函数接收到的第一个参数是’2’,第二个参数是1，所以会返回NaN。</p>
<pre><code>const unary = (fn) =&gt; fn.length &lt;= 1 ? fn : (arg) =&gt; fn(arg)
</code></pre><p>unary函数接收一个函数为参数，如果这个函数接收的参数个数小于等于1什么都不做，否则返回一个新函数，他只接受一个参数arg</p>
<p>接下来我们可以通过unary函数再来完成上述任务</p>
<pre><code>[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(unary(parseInt)) 
// [1, 2, 3]
</code></pre><h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><blockquote>
<p>once函数的任务是只运行一次给定的函数</p>
</blockquote>
<pre><code>const once = (fn) =&gt; {
    let done = false

    return function (...args) {
        return done ? undefined : ((done = true), fn.apply(this, args))
    }
}    
</code></pre><p>下面我们来快速检测一下once函数</p>
<pre><code>const doPayment = once(() =&gt; console.log(&apos;doPayment is done!&apos;))

// 执行第一次
doPayment() // doPayment is done!
// 执行第二次
doPayment() // undefined  
</code></pre><h3 id="memoized"><a href="#memoized" class="headerlink" title="memoized"></a>memoized</h3><blockquote>
<p>memoized函数将已经计算过的结果存储起来，下次再有相同的计算时可以直接从内存中读取</p>
</blockquote>
<p>有以下阶乘函数</p>
<pre><code>let factorial = (n) =&gt; {
    if (n == 0) return 1

    return n * factorial(n - 1)
}
</code></pre><p>此处没有什么特别的，但有一个问题，为了计算3的阶乘，必须要先计算2的阶乘，为什么不能直接给出结果呢？</p>
<pre><code>const memoized = (fn) =&gt; {
    let lookupTable = {}

    return (arg) =&gt; lookupTable[arg] || (lookupTable[arg] = fn(arg))
} 
</code></pre><p>现在我们可以把factorial函数包裹进一个memoized函数来保留他的输出了</p>
<pre><code>let fastFactorial = memoized (factorial) 
</code></pre><p>现在调用 fastFactorial</p>
<pre><code>fastFactorial(5)
// 120
// lookupTable为 Object: {0: 1, 1: 1, 2: 2, 3: 6, 4: 24, 5: 120}

fastFactorial(3)
// 6 直接从lookupTable返回
</code></pre><p>以同样的方式运行，但是比之前会快很多。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第3章     </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/04/07/functional2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/functional2/" itemprop="url">函数式编程（二）：高阶函数（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T22:11:34+08:00">2018-04-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解数据"><a href="#理解数据" class="headerlink" title="理解数据"></a>理解数据</h2><h3 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h3><blockquote>
<p>当一门语言允许函数作为任何其他数据类型使用时，函数被称为<strong>一等公民（First Class Citizens）</strong></p>
</blockquote>
<p>简单的将，JS支持如下几种数据类型：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Object</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
</ul>
<p>而<strong>函数也可以作为JS的一种数据类型</strong>，我们可以把函数存储在变量中，像操作其他类型数据一样操作他，当一门语言允许函数作为任何其他数据类型使用时，函数被称为<strong>一等公民（First Class Citizens）</strong></p>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>把函数存储到一个变量中：</p>
<pre><code>let fn = () =&gt; {}
</code></pre><p>上述代码中，fn就是一个指向函数数据类型的变量，运行下面代码检测fn的类型</p>
<pre><code>typeof fn   //function
</code></pre><p>既然fn是函数的引用，那就可以这样调用他：<code>fn()</code></p>
<h3 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h3><p>将函数以参数的形式传入另一个函数中</p>
<pre><code>let tellType = (arg) =&gt; {
    console.log(typeof arg)
}
</code></pre><p>像tellType传入参数并看他的执行结果</p>
<pre><code>let fn = () =&gt; {
    console.log(&apos;I&apos;m a function&apos;)
}    

tellType(fn) // function
</code></pre><p>如上述代码所示，我们成功的打印出了fn的类型</p>
<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>既然函数也是JavaScript中的数据，就能把他们从其他函数中返回</p>
<pre><code>let crazy = () =&gt; String
crazy() // String() { [native code] }
</code></pre><p>调用crazy函数返回了一个String函数，他只返回了函数的引用，并没有执行。因此可以暂存返回函数的引用，并以如下方式调用</p>
<pre><code>let fn = crazy()
fn(&apos;HOC&apos;)   // HOC
</code></pre><p>或者</p>
<pre><code>crazy()(&apos;HOC&apos;)  // HOC
</code></pre><h2 id="抽象和高阶函数"><a href="#抽象和高阶函数" class="headerlink" title="抽象和高阶函数"></a>抽象和高阶函数</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。</p>
<h3 id="通过高阶函数实现抽象"><a href="#通过高阶函数实现抽象" class="headerlink" title="通过高阶函数实现抽象"></a>通过高阶函数实现抽象</h3><pre><code>const forEach = (arr, fn) =&gt; {
    for (let i = 0; i &lt; arr.length; i++){
        fn(arr[i])
    }
}  
</code></pre><p>上面的forEach函数抽象出了遍历数组的问题。使用API forEach的用户不需要理解forEach是如何实现遍历的，如此问题就被抽象出来了。</p>
<p>创建一个名为unless的函数，这是一个简单的函数，接收一个断言（值为true或false）。如果predicate为false，则调用fn</p>
<pre><code>const unless = (predicate, fn) =&gt; {
    if (!predicate) {
        fn()
    }
}
</code></pre><p>有了unless函数就可以编写一段简洁的代码来查找一个列表中的偶数</p>
<pre><code>forEach([1,2,3,4,5,6,7], (number) =&gt; {
    unless((number % 2), () =&gt; {
        console.log(number, &apos; is even&apos;)
    })
})

// 2 &apos; is even&apos;
// 4 &apos; is even&apos;
// 6 &apos; is even&apos;
</code></pre><p>上面的例子会从数组中获取偶数，如果要从0到100中获取偶数，该如何做呢？</p>
<p>定义一个times函数，times是一个简单的高阶函数，他接收一个数字，并根据调用者提供的次数调用传入的函数。</p>
<pre><code>const times = (times, fn) =&gt; {
    for (let i = 0; i &lt; times; i++){
        fn(i)
    }
}    
</code></pre><p>现在我们解决如何获取0到100中的偶数问题</p>
<pre><code>times(100, (n) =&gt; {
    unless((n % 2), () =&gt; {
        console.log(n, &apos;is even&apos;)
    })
})
</code></pre><p>我们将解题过程中的每一步都抽象了出来，使当前的函数只关心当前的工作，最后再以组合的形式得到了答案，其中过程清晰明了，于是有了简洁的代码</p>
<h2 id="真实的高阶函数"><a href="#真实的高阶函数" class="headerlink" title="真实的高阶函数"></a>真实的高阶函数</h2><h3 id="简单的高阶函数"><a href="#简单的高阶函数" class="headerlink" title="简单的高阶函数"></a>简单的高阶函数</h3><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><blockquote>
<p>every函数接收两个参数，一个数组和一个函数，他使用传入的函数检查数组中的所有元素是否为true</p>
</blockquote>
<pre><code>const every = (arr, fn) =&gt; {
    let result = true

    for (const value of arr) {
        result = result &amp;&amp; fn(value)
    }

    return result
}

every([NaN, NaN, NaN], isNaN)   // true
evert([NaN, NaN, 4], isNaN)     // false
</code></pre><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><blockquote>
<p>some函数与every函数类似，不同的是如果数组中有一个元素通过传入的函数返回true，some函数就返回true</p>
</blockquote>
<pre><code>const some = (arr, fn) =&gt; {
    let result = true

    for (const value of arr) {
        result = result || fn(value)
    }

    return result
} 

some([NaN, NaN, 4], isNaN)  // true
some([2, 3, 4], isNaN)  // false&apos;
</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort函数是JavaScript的Array原型的内置函数。假设我们需要 给一个水果列表排序</p>
<pre><code>let fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;]

fruit.sort()    // [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]
</code></pre><p>sort函数是一个高阶函数，他接收一个函数作为参数，该函数用于帮助sort函数决定排序逻辑。</p>
<pre><code>arr.sort([compareFunction])
</code></pre><p>compareFunction是可选的，如果compareFunction未提供，元素将被转化为字符串并按Unicode编码点顺序排列。<br>在编写compareFunction之前，让我们看一下他实际应该实现什么</p>
<pre><code>function compare(a, b) {
    if (根据某种排序标准a小于b) {
        return -1
    }

    if (根据某种排序标准a大于b) {
        return 1
    }

    // a一定等于b
    return 0
}    
</code></pre><p>假设我们有如下数据</p>
<pre><code>let people = [
    { firstname: &apos;aaFirstName&apos;, lastname: &apos;ccLastName&apos; },
    { firstname: &apos;ccFirstName&apos;, lastname: &apos;aaLastName&apos; },
    { firstname: &apos;bbFirstName&apos;, lastname: &apos;bbLastName&apos; }
]
</code></pre><p>现在需要使用firstname键对数据进行排序</p>
<pre><code>pepple.sort((a, b) =&gt; {return (a.firstname &lt; b.firstname) ? -1 : (a.firstname &gt; b.firstname) ? 1 : 0})
</code></pre><p>如果现在要根据lastname排序</p>
<pre><code>pepple.sort((a, b) =&gt; {return (a.lastname &lt; b.lastname) ? -1 : (a.lastname &gt; b.lastname) ? 1 : 0})
</code></pre><p>知道了compareFunction的算法，我们能做的更好吗？上面的例子中可以看到，我们几乎用重复的代码编写了两个函数去比较firstname和lastname。我们能把上面的逻辑抽象到一个函数中去吗？</p>
<pre><code>const sortBy = (property) =&gt; {
    return (a, b) =&gt; {
        let result = (a[property] &lt; b[property] ? -1 : (a[property] &gt; b[property]) ? 1 : 0)

        return result
    }
}   
</code></pre><p>sortBy函数接收一个名为property的参数，并返回一个接收两个参数的新函数，现在我们可以这样调用</p>
<pre><code>people.sort(sortBy(&apos;firstname&apos;))
people.sort(sortBy(&apos;lastname&apos;))
</code></pre><p>sort函数接收被sortBy函数返回的compareFunction，我们再次抽象出了compareFunction背后的逻辑，使得用户专注与真正的需求。那么持有property参数值的返回函数是如何得来的？下一篇中我们将讨论这个问题。    </p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第3章 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/03/11/functional1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/functional1/" itemprop="url">函数式编程(一)：简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T22:56:21+08:00">2018-03-11</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先来看下数学上的函数：</p>
<blockquote>
<p>f(x)=y</p>
</blockquote>
<p>可以解读为: <strong>函数f，以x作为参数，并返回输出y</strong>；这个简单的定义包含了几个点：</p>
<ul>
<li>函数必须总是接收一个参数</li>
<li>函数必须总是返回一个值</li>
<li>函数应该依据接收到的参数而不是外部环境运行</li>
<li>对于一个给定的X，只会输出唯一的一个Y</li>
</ul>
<p>有了数学上的函数定义，可以理解出程序上的定义：<strong>函数式编程是一种<a href="https://baike.baidu.com/item/%E8%8C%83%E5%BC%8F/22773" target="_blank" rel="noopener">范式</a>，我们能够以此创建仅依赖数据就可以完成自身逻辑的函数（函数不会改变任何外部环境的变量）</strong></p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let percentValue = 5</span><br><span class="line">let calculateTax = (value) =&gt; value/100 * (100 + percentValue)</span><br></pre></td></tr></table></figure>
<p>上面代码中，calculateTax返回一个经过计算的数值，理论上讲，该段代码无任何异议；但该函数在数学意义上就不能称之为一个真正的函数，因为他的执行依赖了一个外部环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let calculateTax = (value, percentValue) =&gt; value/100 * (100 + percentValue)</span><br></pre></td></tr></table></figure>
<p>上面这段代码则可以被成为一个真正的函数了。我们做了什么 -&gt; 在函数内部消除了对外部环境的访问。稍后会介绍这么做的好处。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><blockquote>
<p>引用透明性: 相同的输入都会返回相同的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let identity = (i) =&gt; i</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个函数 <code>identity</code>，他将传入的值作为输出，没有任何依赖的外部环境，该函数满足了引用透明性条件。现在假设该函数被用于其他函数调用之处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(4, 5) + identity(1)</span><br></pre></td></tr></table></figure>
<p>根据引用透明性原则，我们可以把上面的函数转化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(4, 5) + 1</span><br></pre></td></tr></table></figure>
<p>这个过程被称为<strong>替换模型（Substitution Model）</strong></p>
<h3 id="声名式"><a href="#声名式" class="headerlink" title="声名式"></a>声名式</h3><p>给定一个数组，我想分别打印出数组的每一项，有如下两段代码：</p>
<p>A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">arr.forEach((item) =&gt; console.log(item))</span><br></pre></td></tr></table></figure>
<p> 上面两段代码都可以完成我们规定的任务，区别在于：</p>
<ul>
<li>代码A是命令式的</li>
<li>代码B是声名式的</li>
</ul>
<p>回顾一下我们的任务： <strong>打印出数组中的每一项</strong></p>
<ul>
<li>代码A中，我们精确的告诉了程序改怎么做：我们用数组长度的索引编写了一个for循环，然后再打印出数组的每一项，这并不是任务的初衷，而是在<code>精确的告知程序该怎么做</code>，我们称这种解决方案为<strong>命令式</strong></li>
<li>代码B中，程序准确的执行了我们的任务：<strong>打印出数组中的每一项</strong>，这种<code>告知程序做什么的</code>解决方案，我们称之为<strong>声名式</strong></li>
</ul>
<blockquote>
<p>命令式 -&gt; 怎么做<br>声名式 -&gt; 做什么</p>
</blockquote>
<h2 id="函数式编程带来的好处"><a href="#函数式编程带来的好处" class="headerlink" title="函数式编程带来的好处"></a>函数式编程带来的好处</h2><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><blockquote>
<p>纯函数是对给定的输入返回相同的输出的函数</p>
</blockquote>
<pre><code>let double = (value) =&gt; value * 2
</code></pre><p>上面的double函数就是一个纯函数，因为给他一个输入，他总是能返回相同的输出</p>
<h3 id="并发代码"><a href="#并发代码" class="headerlink" title="并发代码"></a>并发代码</h3><blockquote>
<p>根据引用通明原则，我们可以同步的执行函数</p>
</blockquote>
<p>假设我们用JS中的WebWorker来并发的执行多任务，有以下代码</p>
<pre><code>let global = &apos;something&apos;

let function1 = (input) =&gt; {
    // 处理input
    // 改变global
    global = &apos;somethingElse&apos;
}

let function2 = () =&gt; {
    if (global === &apos;something&apos;) {
        // 业务逻辑
    }
}
</code></pre><p>如果我们要并发的执行function1和function2，会因为先后顺序等因素得到不同结果，现在把这些函数改为纯函数</p>
<pre><code>let function1 = (input, global) =&gt; {
    // 处理input
    // 改变global
    global = &apos;somethingElse&apos;
}

let function2 = (global) =&gt; {
    if (global === &apos;something&apos;) {
        // 业务逻辑
    }
}
</code></pre><p>此处我们移动了global变量，把他作为两个函数的参数，使他们变为纯函数。现在我们可以并发的执行两个函数了，不会带来任何问题。</p>
<h3 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h3><blockquote>
<p>既然纯函数总是为给定的输入返回相同的输出，那么我们就能够缓存函数的输出</p>
</blockquote>
<p>假设有如下做耗时计算的函数：</p>
<pre><code>let longRunningFunction = (ip) =&gt; { // do long running tasks and return }
</code></pre><p><strong>如果longRunningFunction是纯函数</strong>，我们知道相同的输入那么他总会返回相同输出，那么我们能不能将函数的结果作为下一个函数的调用呢？</p>
<p>假设我们有一个对象，他存储了longRunningFunction的所有调用结果：</p>
<pre><code>let longRunningFnBookKeeper = {
    2: 3,
    4: 5,
    ...
}
</code></pre><p>现在我们在调用原始函数之前检查key是否在longRunningFnBookKeeper中</p>
<pre><code>let longRunningFnBookKeeper = {
    2: 3,
    4: 5,
    ...
}

// 检查key是否在longRunningFnBookKeeper中
// 如果在返回返回结果否则更新对象
longRunningFnBookKeeper.hasOwnPrototype(ip) ? 
    longRunningFnBookKeeper.hasOwnPrototype[ip] :
    longRunningFnBookKeeper.hasOwnPrototype = longRunningFunction(ip)
</code></pre><p>另一个栗子：</p>
<pre><code>let factorial (n) {
    if (n === 1) return 1
    return n * factorial(n - 1)
}
</code></pre><p>上面的代码是一个阶乘函数，计算n的阶乘，要保存n个调用记录，复杂度O(n)</p>
<img src="/2018/03/11/functional1/1-1.png">
<p>通过缓存的方式将中个阶乘函数改写</p>
<pre><code>let factorial (n, result) {
    if (n === 1) return result
    return factorial(n - 1, n * result)
}
</code></pre><img src="/2018/03/11/functional1/1-2.png">
<p>上面的代码，我们将上一次的计算结果缓存，复杂度O(1)  </p>
<h3 id="管道与组合"><a href="#管道与组合" class="headerlink" title="管道与组合"></a>管道与组合</h3><p>在UNIX和LINUX的平台中有许多用于日常任务的命令</p>
<pre><code>ps -ef | grep nginx
</code></pre><p>上面的命令用于查询系统中的nginx信息，这就是一个典型的组合方式。</p>
<img src="/2018/03/11/functional1/1-3.png">
<p>上图中，X和Y之间的变形关系是函数f，Y和Z的变形关系是g，那么X和Z之间的关系，就是g和f的组合函数： </p>
<pre><code>g(f(x))
</code></pre><p>另一种方式</p>
<pre><code>foo(x).compose(f).compose(g)
</code></pre><p>将值通过链式调用的方式逐级传递</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html</a></li>
<li>《JavaScript ES6 函数编程入门经典》第1章 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/01/28/my-new-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/28/my-new-post/" itemprop="url">my new post</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T17:16:54+08:00">2018-01-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="这是一篇测试文章"><a href="#这是一篇测试文章" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h4><blockquote class="blockquote-center"><p>Talk is cheap, show me your code.</p>
</blockquote>
<blockquote><p>感时花溅泪，恨别鸟惊心。</p>
<footer><strong>杜甫</strong><cite>《春望》</cite></footer></blockquote>
<p><br></p>
<div class="note primary"><p></p><h3>title</h3><br>content<p></p></div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/01/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/28/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T17:04:52+08:00">2018-01-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/1.jpeg"
                alt="lemonleon" />
            
              <p class="site-author-name" itemprop="name">lemonleon</p>
              <p class="site-description motion-element" itemprop="description">码农/猫奴/瞎烧友/伪影迷</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lvvlan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lemonleon</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.2</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
