<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.2',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="码农/猫奴/瞎烧友/伪影迷" />


<meta name="description" content="码农/猫奴/瞎烧友/伪影迷">
<meta property="og:type" content="website">
<meta property="og:title" content="lemonleon">
<meta property="og:url" content="http://lvvlan.github.io/index.html">
<meta property="og:site_name" content="lemonleon">
<meta property="og:description" content="码农/猫奴/瞎烧友/伪影迷">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lemonleon">
<meta name="twitter:description" content="码农/猫奴/瞎烧友/伪影迷">






  <link rel="canonical" href="http://lvvlan.github.io/"/>


  <title>lemonleon</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/lvvlan" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lemonleon</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">use code, change world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            标签<span class="badge">4</span>
              </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            分类<span class="badge">3</span>
              </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            归档<span class="badge">11</span>
              </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            公益 404</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2019/03/07/algorithm1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/algorithm1/" itemprop="url">N皇后问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T08:21:44+08:00">2019-03-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>N皇后问题是经典八皇后问题的扩展：在N*N的棋盘上，有N个皇后需要放置，需满足任意两个皇后不能位于同一行、同一列或者是同一对角线上，求一共有几种放置方法。</p>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题</p>
<h2 id="回溯解法"><a href="#回溯解法" class="headerlink" title="回溯解法"></a>回溯解法</h2><p>N皇后问题是一个经典的回溯法的例子，核心思想就是逐行（或逐列）放置，若某一行没有可供放置的位置了，说明前面的放置有误，故回溯到上一行寻找下一个可能的位置。N皇后问题是一个NP-Hard问题，其算法复杂度是指数复杂度的。</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><ul>
<li><p>回溯代码</p>
<p>  const queen = function (row = 0) {</p>
<pre><code>if (row === n) {
    total++
    all.push([...c])
} else {
    for (let col = 0; col &lt; n; col++) {
        c[row] = col
        if (check(row)) {
            queen(row + 1)
        }
    }
}
</code></pre><p>  }</p>
</li>
<li><p>check代码</p>
<p>  const check = function (row) {</p>
<pre><code>for (let i = 0; i &lt; row; i++){
    // 纵向
    if (c[row] === c[i]) return false
    // 斜向相减
    if (c[row] - row === c[i] - i) return false
    // 斜向相加
    if (c[row] + row === c[i] + i) return false
}
return true
</code></pre><p>  }    </p>
</li>
</ul>
<p> 后续会更新一下具体的解法思路</p>
<p> 源码地址：<a href="https://github.com/lvvlan/NQueen" target="_blank" rel="noopener">https://github.com/lvvlan/NQueen</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2019/02/13/math1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/math1/" itemprop="url">计算机为什么使用二级制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T23:00:33+08:00">2019-02-13</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数学/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是二进制计数法"><a href="#什么是二进制计数法" class="headerlink" title="什么是二进制计数法"></a>什么是二进制计数法</h2><p>为了更好的理解二进制，我们先来简单回顾下人类计数的发展历史。</p>
<p>原始时代，人们用路边的小石子，来统计放牧归来羊的数量，后来，罗马人用手指作为计数工具，并在羊皮上画出 I、II、III 来代替手指的数量，表示一只手时，就写成“V”形，两只手”VV”等。</p>
<p>公元3世纪左右，印度数据学家（也有说法是阿拉伯人）发明了阿拉伯数字。阿拉伯数字由从0到9这样10个计数符号组成，并采用<code>进位制法</code>，高位在左，低位在右，从左往右书写。由于阿拉伯数字笔画简单，验算便利，因此逐渐在各国流行起来，成为世界的通用数字。</p>
<p>让我们来观察一个数字：1234</p>
<pre><code>1234 = 1 * 1000 + 2 * 100 + 3 * 10 + 4 * 1
     = 1 * 10^3 + 2 * 10^2 + 3 * 10^1 + 4 * 10^0
</code></pre><p> 在这个新的表达式里，10被称为十进制的<code>基数</code>，也是十进制中十的由来。明白了十进制，我们试着用类似的思路来理解二进制，这里10011010010代表十进制中的多少 </p>
<pre><code>10011010010 = 1 * 2^10 + 0 * 2^10 + 0 * 2^9 + 0 * 2^8 + 1 * 2^7 + 0 * 2^10 + 1 * 2^6 + 0 * 2^5 + 1 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0
            = 1234
</code></pre><p>至此，十进制与二级制理论部分我们理解清楚了，但是新的问题来了：既然有十进制和二进制，为啥要用二进制呢？</p>
<h2 id="为什么是二进制？"><a href="#为什么是二进制？" class="headerlink" title="为什么是二进制？"></a>为什么是二进制？</h2><ul>
<li>现实</li>
</ul>
<p>按照人的逻辑思维，十进制是要比二进制容易接受多的，但是计算机没人那么“聪明”，我觉得计算机采用二进制和现代计算机系统的硬件实现有关：组成计算机逻辑系统的电路，通常只有两种状态，即开关的接通与断开。</p>
<p>断开的状态我们用“0”来表示，接通的状态用“1”来表示。由于每位数据只有断开与接通两种状态，所以即便系统受到一定程度的干扰时，它仍然能够可靠地分辨出数字是“0”还是“1”。因此，在具体的系统实现中，二进制的数据表达具有抗干扰能力强、可靠性高的优点。</p>
<p>相比之下，如果用十进制设计具有 10 种状态的电路，情况就会非常复杂，判断状态的时候出错的几率就会大大提高。</p>
<p>另外，二进制也非常适合逻辑运算。逻辑运算中的“真”和“假”，正好与二进制的“0”和“1”两个数字相对应。逻辑运算中的加法（“或”运算）、乘法（“与”运算）以及否定（“非”运算）都可以通过“0”和“1”的加法、乘法和减法来实现。</p>
<ul>
<li>梦回三国</li>
</ul>
<p>让我们再通过一个具体的例子来感受一下二进制：</p>
<p>诸葛亮为了北定中原兴复汉室，亲自驻守西城，此时的司马懿兵强马壮，诸葛亮派爱将马谡驻守街亭，与西城首尾相望。</p>
<p>街亭山高谷深，地势险要，为兵家必争之地，进可攻关中，退可守陇右。</p>
<p>诸葛亮叮嘱马谡：魏军若来100人，你就点亮1盏“孔明灯”通知我，我想清楚知道魏国来了多少敌军，我派王平和赵云做好准备，这次必将活捉司马懿。</p>
<p>马谡脑瓜儿挺机灵：丞相我懂了，若是敌人来了100个，我就放飞1盏孔明灯。若是敌人来了1000个，我就放飞10盏孔明灯。若是敌人来了10000个，我就放飞100盏个孔明灯。若是敌人来了100000个，我就放飞1000盏孔明灯。</p>
<p>诸葛亮差点跳起来：你以为孔明灯那么好做，放飞250盏孔明灯，你知道要多少军费吗？今天下三分，益州疲弊，你还这么浪费。</p>
<p>马谡脑眼珠一转：丞相我懂了，敌人来了一个，我就点亮一次，这样的话，我就只需要1盏孔明灯了。</p>
<p>诸葛亮长叹了口气：幼常啊，你想一想，我现在快五十岁的人了，又近视得厉害，你认为我能够看得清楚你点了多少次吗？而且你这点来点去的，中间万一数错了呢？</p>
<p>马谡这下傻眼了：丞相，求答案。</p>
<p>诸葛亮摇了摇羽毛扇：你得学学二进制，多安几盏孔明灯，你把它们装在街亭最高处，但注意，必须以同样的距离排列。</p>
<p>马谡完全糊涂了：丞相，什么是二进制？</p>
<p>诸葛亮摇了摇羽毛扇：二进制，乃天人之学也。</p>
<p>两人耳语甚久，马谡似懂非懂，最终拜服，丞相乃天人也。</p>
<p>诸葛亮道：现今你明白了二进制，只须排列好10盏灯，就可以将敌情准确上报。我在西城定好位置，按照定好的方位观察亮灯的位置，就可以运筹帷幄。</p>
<p>0000000000，8盏灯全灭，说明无敌军来犯。（状态0） </p>
<p>0000000001，第一个位置亮了灯，来了100个敌人，你负责干掉他就行了。（状态1） </p>
<p>0000000010，第二个位置亮了灯，来了200个敌人，小菜一碟，街亭无忧。（状态2）</p>
<p>0000000011，第一二位置都亮了灯，来了300个敌人，也不是什么大事。（状态3）</p>
<p>0000000100，第三个位置亮了灯，来了400个敌人，派出小股军队灭了他们。（状态4）</p>
<p>0000000101，第一三位置都亮了灯，来了500个敌人，得小小注意下了。（状态5）</p>
<p>诸葛亮担心马谡还是没有真正地听明白，特意给了他一张密码对照表，按照这个密码表，点起孔明灯就是了。</p>
<p>附表：</p>
<p>10进制编号 灯泡表示</p>
<p>状态 1 0000000001</p>
<p>状态 2 0000000010</p>
<p>状态 3 0000000011</p>
<p>状态 4 0000000100</p>
<p>状态 5 0000000101</p>
<p>……（以此类推）</p>
<p>状态 996   1111100100</p>
<p>状态 997   1111100101</p>
<p>状态 998   1111100110</p>
<p>状态 999   1111100111</p>
<p>状态 1000  1111101000</p>
<p>这就是二进制的基本工作原理，说实在的，确实比十进制有用多了。<br>（以上例子摘自网络）</p>
<ul>
<li>小知识</li>
</ul>
<p>除了二进制，其实还有三进制的计算机，但因为种种原因没有撼动二进制的霸主地位。三进制的思路是电压有正负0三种，这样的话，相反数就不需要维护，这是最大的特点，比二进制要减少很多运算。关于三进制计算机可以参考下这篇文章 <a href="https://www.v2ex.com/t/114165" target="_blank" rel="noopener">为什么三进制计算机没有流行下来？如果现在是三进制会怎么样？</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/column/article/71840" target="_blank" rel="noopener">《程序猿的数学基础课：二进制：不了解计算机的源头，你学什么编程 - 黄申》</a></li>
<li><a href="http://www.elecfans.com/d/689014.html" target="_blank" rel="noopener">《计算机为什么是二进制？》</a></li>
<li><a href="https://www.zhihu.com/question/20830886" target="_blank" rel="noopener">《二进制有什么好处，为何电脑都采用二进制？》</a></li>
<li><a href="https://www.v2ex.com/t/114165" target="_blank" rel="noopener">为什么三进制计算机没有流行下来？如果现在是三进制会怎么样？</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/06/26/functional7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/functional7/" itemprop="url">函数式编程（六）：函子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-26T08:25:12+08:00">2018-06-26</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是函子"><a href="#什么是函子" class="headerlink" title="什么是函子"></a>什么是函子</h2><blockquote>
<p>函子是一个普通对象，他实现了map函数，在遍历每个对象值的时候生成一个新对象</p>
</blockquote>
<h3 id="函子是容器"><a href="#函子是容器" class="headerlink" title="函子是容器"></a>函子是容器</h3><p>下面的代码创造了一个简单的容器，他能够持有任何传给他的值</p>
<pre><code>class Container {
    constructor (val) {
        this.value = val
    }
}
</code></pre><p>应用Container</p>
<pre><code>let testValue = new Container(3)
// Container(value: 3)
</code></pre><p>通过of静态方法省略 new 关键字</p>
<pre><code>class Container {
    constructor (val) {
        this.value = val
    }
    static of (val) {
            return new this(val)
        }
}

testValue = Container.of(3)
// Container(value: 3)
</code></pre><h3 id="函子实现了map方法"><a href="#函子实现了map方法" class="headerlink" title="函子实现了map方法"></a>函子实现了map方法</h3><p>map函数允许我们使用当前Container持有的值调用任何函数</p>
<pre><code>class Container {
    constructor (val) {
        this.value = val
    }

    map (fn) {
        return new Container(fn(this.value))
    }
}
</code></pre><p>应用</p>
<pre><code>let double = () =&gt; x + x

Container.of(3).map(double) // Container(value: 6)
</code></pre><p>map函数返回了以传入函数的执行结果为值的Container实例，所以允许我们进行链式操作</p>
<pre><code>Container.of(3)
            .map(double)
            .map(double)
            .map(double)    // Container(value: 24)
</code></pre><h2 id="MayBe函子"><a href="#MayBe函子" class="headerlink" title="MayBe函子"></a>MayBe函子</h2><p>函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。</p>
<pre><code>class MayBe extends Container {
    isNothing () {
        return this.value === null || this.value === undefined
    }

    map (fn) {
        return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this.value))
    }
}

MayBe.of(null).map((s) =&gt; s.toUpperCase())  // MayBe {value: null}
</code></pre><h2 id="ap函子"><a href="#ap函子" class="headerlink" title="ap函子"></a>ap函子</h2><p>  函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，y一个函子的值是数值，另一干函子的值是函数。</p>
<pre><code>function addTwo (x) {
    return x + 2
}

const A = Container.of(2)
const B = Container.of(addTwo)
</code></pre><p>上面代码中，A函子的值是2，B函子的值是addTwo，有时我们想让B函子内部的函数可以用A函子内部的值，这时就需要用到ap函子</p>
<pre><code>class Ap extends Container {
    ap (fn) {
        return Ap.of(this.value(fn.value))
    }
}

Ap.of(addTwo).ap(Container.of(2))   // Ap {value: 4}
</code></pre><p>ap函子的意义在于，对于那些多参的函数，可以从容器中取值，实现函子的链式操作</p>
<pre><code>function add (x) {
    return function (y) {
        return x + y
    }
}    

Ap.of(add).ap(Maybe.of(2)).ap(Maybe.of(3))  // Ap {value: 5}
</code></pre><h2 id="Monad函子"><a href="#Monad函子" class="headerlink" title="Monad函子"></a>Monad函子</h2><p>函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。<code>Monad 函子的作用是，总是返回一个单层的函子。</code></p>
<pre><code>class Monad {
    constructor (val) {
        this.value = val
    }

    map (fn) {
        return new Monad(fn(this.value))
    }

    join () {
        return this.value
    }

    chain (f) {
        return this.map(f).join()
    }

      static of (val) {
            return new this(val)
        }
}
</code></pre><p>现在Monad可以帮我们打开嵌套的函子了</p>
<pre><code>let example = Monad.of(Monad.of(5))

example.chain((x) =&gt; x * x)
</code></pre><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第8章  </li>
<li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程</a>    </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/06/10/functional6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/functional6/" itemprop="url">函数式编程（五）：组合与管道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-10T22:54:00+08:00">2018-06-10</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><blockquote>
<p>将一个函数的输出作为另一个函数的输入</p>
</blockquote>
<p>来看一个简单的compose函数，他的功能是将两个函数组合起来，并将其中一个函数的输入作为另一个函数的输出</p>
<pre><code>const compose = (a, b) =&gt; (c) =&gt; a(b(c))
</code></pre><p>假设我们想对一个给定的数字四舍五入求值，如果不适用组合，我们可以通过如下的做法</p>
<pre><code>let data = parseFloat(&apos;3.56&apos;)
let number = Math.round(data)   // 4
</code></pre><p>下面通过compose函数解决该问题</p>
<pre><code>let number = compose(Math.round, parseFloat)
number(&apos;3.56&apos;)  // 4
</code></pre><p>上面的过程，就是函数式的组合！我们将两个函数组合在一起以便能即时地构建出一个新函数！值得一提的是，函数Math.round和parseFloat只有在调用number函数的时候才会执行</p>
<p>下面看另一个栗子：求一个字符串中的单词数量</p>
<pre><code>let splitIntoSpaces = (str) =&gt; str.split(&apos; &apos;)
let count = (arr) =&gt; arr.length

const countWords = compose(count, splitIntoSpaces)

countWords(&apos;hello your reading about composition&apos;)  // 5
</code></pre><h3 id="引入curry与partial"><a href="#引入curry与partial" class="headerlink" title="引入curry与partial"></a>引入curry与partial</h3><p>现在的compose，仅当函数接收一个参数时，才能将函数组合，那多参的函数该如何组合呢？我们可以通过上一章定义的curry和partial函数来实现。</p>
<p>回顾一下我们之前的map与filter函数：</p>
<ul>
<li><p>map</p>
<pre><code>const map = (arr, fn) =&gt; {
    let results = []
    for(let value of arr){
        results.push(fn(value))
    }
    return results
}

map([1, 2, 3], (x) =&gt; x * x)    // [1, 4, 9]
</code></pre></li>
<li><p>filter</p>
<pre><code>const filter = (arr, fn) =&gt; {
    let results = []
    for(let value of arr){
        (fn(value)) ? results.push(value) : undefined
    }
    return results
}    
</code></pre></li>
</ul>
<p>我们不能直接将map和filter函数进行组合，因为他们都接收两个参数，第一个参数是数组，第二个参数是操作数组的函数，但是我们可以借助于partial函数。</p>
<p>假设我们有如下数据</p>
<pre><code>let apressBooks = [
  {
    &quot;id&quot;: 111,
    &quot;title&quot;: &quot;C# 6.0&quot;,
    &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
    &quot;rating&quot;: [4.7],
    &quot;reviews&quot;: [{good : 4 , excellent : 12}]
  },
  {
    &quot;id&quot;: 222,
    &quot;title&quot;: &quot;Efficient Learning Machines&quot;,
    &quot;author&quot;: &quot;Rahul Khanna&quot;,
    &quot;rating&quot;: [4.5],
    &quot;reviews&quot;: []
  },
  {
    &quot;id&quot;: 333,
    &quot;title&quot;: &quot;Pro AngularJS&quot;,
    &quot;author&quot;: &quot;Adam Freeman&quot;,
    &quot;rating&quot;: [4.0],
    &quot;reviews&quot;: []
  },
  {
    &quot;id&quot;: 444,
    &quot;title&quot;: &quot;Pro ASP.NET&quot;,
    &quot;author&quot;: &quot;Adam Freeman&quot;,
    &quot;rating&quot;: [4.2],
    &quot;reviews&quot;: [{good : 14 , excellent : 12}]
  }
]
</code></pre><p>同时我们定义一些辅助的小函数</p>
<pre><code>// 获取满分评价图书
let filterOutStandingBooks = (book) =&gt; book.rating[0] === 5
// 获取评价大于4.5的图书
let filterGoodBooks = (book) =&gt; book.rating[0] &gt; 4.5
// 获取评价小于3.5的图书
let filterBadBooks = (book) =&gt; book.rating[0] &lt; 3.5
// 获取图书的title和author
let projectTitleAndAuthor = (book) =&gt; ({title: book.title, author: book.author})
// 获取图书的author
let projectAuthor = (book) =&gt; ({author: book.author})
// 获取图书的title
let projectTitle = (book) =&gt; ({title: book.title})
</code></pre><p>现在，我们想获取评级高于4.5的图书的标题和作者，我们可以只用compose和partial实现</p>
<pre><code>let queryGoodBooks = partial(filter, undefined, filterGoodBooks)
let mapTitleAndAuthor = partial(map, undefined, projectTitleAndAuthor)

let titleAndAuthorForGoodBooks = compose(mapTitleAndAuthor, queryGoodBooks)

titleAndAuthorForGoodBooks(apressBooks) 
// 输出
[{
    author: &quot;ANDREW TROELSEN&quot;
    title: &quot;C# 6.0&quot;
}]   
</code></pre><p><code>组合的思想就是把小函数组合成一个大函数，简单的函数容易阅读、测试和维护</code></p>
<h3 id="组合多个函数"><a href="#组合多个函数" class="headerlink" title="组合多个函数"></a>组合多个函数</h3><p>当前版本的compose只能组合两个给定的函数，如何组合三个、四个或者更多函数呢？下面重写compose函数，以便它能够即时地组合多个函数</p>
<pre><code>const compose = (...args) =&gt; (value)
                =&gt; reduce(args.reverse(), (acc, fn) =&gt; fn(acc), value)
</code></pre><p>下面验证改写过的compose函数，在第一个例子中，假设我们想知道给定字符串的单词数是奇数还是偶数</p>
<pre><code>// 验证奇数偶数
let oddOrEven = (ip) =&gt; ip % 2 === 0 ? &apos;even&apos; : &apos;odd&apos;
// 通过compose将三个函数组合起来
let oddOrEvenWords = compose(oddOrEven, count, splitIntoSpaces)

oddOrEvenWords(&apos;hello your reading about composition&apos;)  // &apos;odd&apos;
</code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>compose函数数据流的运行机制，是从右至左，因为最右侧的函数首先执行，将数据传递给下一个函数，以此类推，最左侧的函数最后执行。但也有另外一种方式：从左至右执行，最左侧的函数最先执行，最右侧的函数最后执行。类似于Unix下的 ‘|’ 操作，Unix命令的数据流是从左至右的。我们将实现一个新的名为pipe的函数，他与compose所做的事情相同，只不过改变了数据流的方向</p>
<pre><code>const pipe = (...args) =&gt; (value)
                =&gt; reduce(args, (acc, fn) =&gt; fn(acc), value)
</code></pre><p>下面通过重新执行上街的例子快速检查一下pipe函数</p>
<pre><code>let oddOrEvenWords = pipe(splitIntoSpaces, count, oddOrEven)

oddOrEvenWords(&apos;hello your reading about composition&apos;)  // &apos;odd&apos; 
</code></pre><h2 id="组合的优势"><a href="#组合的优势" class="headerlink" title="组合的优势"></a>组合的优势</h2><h3 id="组合满足结合律"><a href="#组合满足结合律" class="headerlink" title="组合满足结合律"></a>组合满足结合律</h3><p>函数式组合总是满足结合律</p>
<pre><code>compose(f, compose(g, h)) === compose(compose(f, g), h)
</code></pre><p>结合律带来的好处就是允许我们把函数组合到各自所需的compose函数中</p>
<pre><code>const countWords = compose(count, splitIntoSpaces)
const oddOrEvenWords = compose(oddOrEven, countWords)

// or
const countOddOrEven = compose(oddOrEven, count)
const oddOrEvenWords = compose(countOddOrEven, splitIntoSpaces)
</code></pre><h3 id="使用tap函数调试"><a href="#使用tap函数调试" class="headerlink" title="使用tap函数调试"></a>使用tap函数调试</h3><p>tap函数是underscore.js中的一个函数，主要左右是在一个链式调用中对中间结果执行某些操作。我们定义一个类似的identity函数，主要实现打印compose中间结果</p>
<pre><code>const identity = (ip) =&gt; {
    console.log(ip)
    return ip
}
</code></pre><p>接下来就可以配合compose函数使用</p>
<pre><code>compose(oddOrEven, count, identity, splitIntoSpaces)(&apos;test string&apos;)
// 输出
[&apos;test&apos;, &apos;string&apos;]
&apos;even&apos;    
</code></pre><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第7章  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/06/03/functional5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/functional5/" itemprop="url">函数式编程（四）：柯里化与偏应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T21:23:43+08:00">2018-06-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote>
<p>柯里化是把一个多参数函数转化为一个嵌套的一元函数的过程</p>
</blockquote>
<p>假设有一个名为add的函数</p>
<pre><code>const add = (x, y) =&gt; x + y
</code></pre><p>这是一个简单的求和函数，没有特别之处。下面是add函数的柯里化版本</p>
<pre><code>const addCurried = x =&gt; y =&gt; x + y
</code></pre><p> 可以用如下方式调用</p>
<pre><code>const addCurried(2)(2)
</code></pre><p>我们手动的把接收两个参数的add函数转化为含有嵌套的一元函数addCurried。下面展示如何把该处理过程转化为一个名为curry的方法</p>
<pre><code>const curry = function (binaryFn) {
    return function (arg1) {
        return function (arg2) {
            return binaryFn(arg1, arg2)
        }
    }
} 
</code></pre><p>现在可以通过curry函数把add函数转化为一个柯里化版本</p>
<pre><code>let autoCurriedAdd = curry(add)

autoCurriedAdd(2)(2)    // 4
</code></pre><h2 id="日志函数-应用柯里化"><a href="#日志函数-应用柯里化" class="headerlink" title="日志函数 - 应用柯里化"></a>日志函数 - 应用柯里化</h2><p>简单的loggerHelper函数</p>
<pre><code>const loggerHelper = (mode, initMsg, errMsg, lineNo) =&gt; {
    if (mode === &apos;DEBUG&apos;) {
        console.debug(initMsg, errMsg + &apos;at line: &apos; + lineNo)
    } else if (mode === &apos;ERROR&apos;) {
        console.error(initMsg, errMsg + &apos;at line: &apos; + lineNo)
    } else if (mode === &apos;WARN&apos;) {
        console.warn(initMsg, errMsg + &apos;at line: &apos; + lineNo)
    } else {
        throw &apos;Wrong mode&apos;
    }
}   
</code></pre><p>当团队中任何开发者需要向控制台打印State.js文件中的错误时，可以用以下方式使用函数</p>
<pre><code>loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;Invalid argument passed&apos;, 23)
loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;undefined argument&apos;, 223)
loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;curry function is not defined&apos;, 3)
loggerHelper(&apos;ERROR&apos;, &apos;ERROR at State.js&apos;, &apos;slice is not defined&apos;, 31)
</code></pre><p> 不难看出，我们在所有的调用中都重复使用了mode和initMsg，能通过柯里化的方式调用吗？答案是可以的，但是目前我们的柯里化只能处理二元函数，那么多个参数该如何柯里化呢？下面我们完善curry函数，他可以处理任何含有多个参数的函数</p>
<pre><code>let curry = (fn) =&gt; {
    if (typeof fn !== &apos;function&apos;) throw new Error(&apos;No function provided&apos;)

    return function curriedFn(...args) {
        if (args.length &lt; fn.length) {
            return function (...rest) {
                return curriedFn.apply(null, args.concat(Array.from(rest)))
            }
        }

        return fn.apply(null, args)
    }
}
</code></pre><p>回顾日志函数，下面通过curry解决前面两个重复参数的问题</p>
<pre><code>let ErrorLogger = curry(loggerHelper)(&apos;ERROR&apos;)(&apos;ERROR at State.js&apos;)  
let DebugLogger = curry(loggerHelper)(&apos;DEBUG&apos;)(&apos;DEBUG at State.js&apos;)
let WarnLogger = curry(loggerHelper)(&apos;WARN&apos;)(&apos;WARN at State.js&apos;)

// 错误
ErrorLogger(&apos;error message&apos;, 21)
// 调试
DebugLogger(&apos;debug message&apos;, 33)
// 警告
WarnLogger(&apos;warn message&apos;, 56)
</code></pre><h2 id="柯里化实战"><a href="#柯里化实战" class="headerlink" title="柯里化实战"></a>柯里化实战</h2><h3 id="在数组内容中查找数字"><a href="#在数组内容中查找数字" class="headerlink" title="在数组内容中查找数字"></a>在数组内容中查找数字</h3><p>假设我们要查找含有数字的数组内容</p>
<pre><code>let match = curry(function (exp, str) {
    return str.match(exp)
})

let hasNumber = match(/[0-9]+/)

let filter = curry(function (fn, arr) {
    return arr.filter(fn)
})   

let findNumberInArray = filter(hasNumber)

findNumberInArray([&apos;js&apos;, &apos;number1&apos;])    // [&apos;number1&apos;]
</code></pre><h3 id="求数组的平方"><a href="#求数组的平方" class="headerlink" title="求数组的平方"></a>求数组的平方</h3><pre><code>let map = curry(function (fn, arr) {
   return arr.map(fn)
})

let squareAll = map((x) =&gt; x * x)

squareAll([1, 2, 3])   //[1, 4, 9]
</code></pre><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><h3 id="偏应用"><a href="#偏应用" class="headerlink" title="偏应用"></a>偏应用</h3><p>假设我们要每10毫秒做一组操作，可以通过setTimeout函数以如下方式实现</p>
<pre><code>setTimeout(() =&gt; console.log(&apos;Do X task&apos;), 10)
setTimeout(() =&gt; console.log(&apos;Do Y task&apos;), 10)
</code></pre><p>我们为每个setTimeout函数调用都传入了10。能使用curry函数解决吗？答案是否定的，因为curry函数应用参数的处理方式是从左到右，由于我们想根据需要传递函数，将10保存为常量，所以不能以这种方式使用curry</p>
<h3 id="实现偏函数"><a href="#实现偏函数" class="headerlink" title="实现偏函数"></a>实现偏函数</h3><pre><code>const partial = function (fn, ...partialArgs) {
    let args = partialArgs
    return function (...fullArguments) {
        let arg = 0
        for (let i = 0; i &lt; args.length &amp;&amp; arg &lt; fullArguments.length; i++) {
            if (args[i] === undefined) {
                args[i] = fullArguments[arg++]
            }
            return fn.apply(null, args)
        }
    }
}
</code></pre><p>对刚刚的问题应用偏函数</p>
<pre><code>let delayTenMs = partial(setTimeout, undefined, 10)
delayTenMs(() =&gt; console.log(&apos;delay ten ms!&apos;))
</code></pre><p>另一个应用</p>
<pre><code>let parseInt2 = partial(parseInt, undefined, 2)
parseInt2(1010) // 10
</code></pre><p>但是现在有个问题，如果我们在调用一次，传入不同的参数，却始终返回上一次的结果</p>
<pre><code>parseInt2(10)   // 10
</code></pre><p>这是由于我们将引用的args直接更改造成的，接下来我们改进这个偏函数</p>
<pre><code>const partial2 = function (fn,...partialArgs){
    let args = Array.from(partialArgs)
    return function(...fullArguments) {
        let arg = 0;

        for (let i = 0; i &lt; args.length &amp;&amp; arg &lt; fullArguments.length; i++) {
            if (partialArgs[i] === undefined) {
                args[i] = fullArguments[arg++];
            }
            return fn.apply(this, args);
        }
    }
}
</code></pre><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第6章 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/05/07/functional4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/functional4/" itemprop="url">函数式编程（三）：数组的函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T08:37:22+08:00">2018-05-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的实现与forEach非常相似，区别是用一个新的数组捕获了结果</p>
<pre><code>const map = (arr, fn) =&gt; {
    let results = []
    for(let value of arr){
        results.push(fn(value))
    }
    return results
}

map([1, 2, 3], (x) =&gt; x * x)    // [1, 4, 9]
</code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><pre><code>let apressBooks = [
  {
    &quot;id&quot;: 111,
    &quot;title&quot;: &quot;C# 6.0&quot;,
    &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
    &quot;rating&quot;: [4.7],
    &quot;reviews&quot;: [{good : 4 , excellent : 12}]
  },
  {
    &quot;id&quot;: 222,
    &quot;title&quot;: &quot;Efficient Learning Machines&quot;,
    &quot;author&quot;: &quot;Rahul Khanna&quot;,
    &quot;rating&quot;: [4.5],
    &quot;reviews&quot;: []
  },
  {
    &quot;id&quot;: 333,
    &quot;title&quot;: &quot;Pro AngularJS&quot;,
    &quot;author&quot;: &quot;Adam Freeman&quot;,
    &quot;rating&quot;: [4.0],
    &quot;reviews&quot;: []
  },
  {
    &quot;id&quot;: 444,
    &quot;title&quot;: &quot;Pro ASP.NET&quot;,
    &quot;author&quot;: &quot;Adam Freeman&quot;,
    &quot;rating&quot;: [4.2],
    &quot;reviews&quot;: [{good : 14 , excellent : 12}]
  }
];  
</code></pre><p>假设我们想获取评级高于4.5的图书列表，如何完成呢？这显然不是map能解决的问题。但是我们需要一个类似map的函数，他只需要在把结果放入数组前检查一个条件。</p>
<pre><code>const filter = (arr, fn) =&gt; {
    let results = []
    for(let value of arr){
        (fn(value)) ? results.push(value) : undefined
    }
    return results
} 

filter(apressBooks, (book) =&gt; book.rating[0] &gt; 4.5)
</code></pre><p>返回值</p>
<pre><code>[{
    &quot;id&quot;: 111,
    &quot;title&quot;: &quot;C# 6.0&quot;,
    &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
    &quot;rating&quot;: [4.7],
    &quot;reviews&quot;: [{good : 4 , excellent : 12}]
  }] 
</code></pre><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><p>为了达成目标，我们经常需要连接很多函数。例如，从apressBooks中获取含有title和author对象且评级高于4.5的对象。</p>
<pre><code>map(filter(apressBooks, (book) =&gt; book.rating[0] &gt; 4.5), (book) =&gt; {
    return {title: book.title, author: book.author}
})
</code></pre><h2 id="concatAll"><a href="#concatAll" class="headerlink" title="concatAll"></a>concatAll</h2><p>下面对apressBooks稍作修改</p>
<pre><code>let apressBooks = [
  {
    name : &quot;beginners&quot;,
    bookDetails : [
      {
        &quot;id&quot;: 111,
        &quot;title&quot;: &quot;C# 6.0&quot;,
        &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
        &quot;rating&quot;: [4.7],
        &quot;reviews&quot;: [{good : 4 , excellent : 12}]
      },
      {
        &quot;id&quot;: 222,
        &quot;title&quot;: &quot;Efficient Learning Machines&quot;,
        &quot;author&quot;: &quot;Rahul Khanna&quot;,
        &quot;rating&quot;: [4.5],
        &quot;reviews&quot;: []
      }
    ]
  },
  {
      name : &quot;pro&quot;,
      bookDetails : [
      {
        &quot;id&quot;: 333,
        &quot;title&quot;: &quot;Pro AngularJS&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.0],
        &quot;reviews&quot;: []
      },
      {
        &quot;id&quot;: 444,
        &quot;title&quot;: &quot;Pro ASP.NET&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.2],
        &quot;reviews&quot;: [{good : 14 , excellent : 12}]
      }
    ]
  }
];  
</code></pre><p>现在回顾上一节的问题，获取含有title和author字段且评价高于4.5的图书。首先使用map函数</p>
<pre><code>map(apressBooks, (book) =&gt; {
    return book.bookDetails
})
</code></pre><p>返回值</p>
<pre><code>[
    [
      {
        &quot;id&quot;: 111,
        &quot;title&quot;: &quot;C# 6.0&quot;,
        &quot;author&quot;: &quot;ANDREW TROELSEN&quot;,
        &quot;rating&quot;: [4.7],
        &quot;reviews&quot;: [{good : 4 , excellent : 12}]
      },
      {
        &quot;id&quot;: 222,
        &quot;title&quot;: &quot;Efficient Learning Machines&quot;,
        &quot;author&quot;: &quot;Rahul Khanna&quot;,
        &quot;rating&quot;: [4.5],
        &quot;reviews&quot;: []
      }
    ],
    [
      {
        &quot;id&quot;: 333,
        &quot;title&quot;: &quot;Pro AngularJS&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.0],
        &quot;reviews&quot;: []
      },
      {
        &quot;id&quot;: 444,
        &quot;title&quot;: &quot;Pro ASP.NET&quot;,
        &quot;author&quot;: &quot;Adam Freeman&quot;,
        &quot;rating&quot;: [4.2],
        &quot;reviews&quot;: [{good : 14 , excellent : 12}]
      }
    ]
]
</code></pre><p>map函数的返回值包含了数组中的数组，因为bookDetails本身就是一个数组，如果直接传给filter将会遇到问题。concatAll函数的作用就是把所有嵌套数组连接到一个数组中。</p>
<pre><code>const concatAll = (arr) =&gt; {
    let results = []
    for(let value of arr){
        results.push.apply(results, value)
    }
    return results
}    
</code></pre><p>接下来用concatAll将嵌套数组转化为费嵌套数组</p>
<pre><code>concatAll(
    map(apressBooks, (book) =&gt; {
        return book.bookDetails
    })
)    
</code></pre><p>返回的结果将会是转化过的数组，然后可以用filter继续连接操作   </p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>有如下数组，需要求和</p>
<pre><code>let useless = [1,2,3,4,5]
</code></pre><p>reduce代码实现</p>
<pre><code>const reduce = (arr, fn, initVal) =&gt; {
    let acc

    if(initVal != undefined){
        acc = initVal
    }else{
        acc = arr[0]
    }

    if(initVal === undefined){
        for(let i=1; i&lt;arr.length; i++){
            acc = fn(acc, arr[i])
        }
    }else{
        for(let val of arr){
            acc = fn(acc, val)
        }
    }

    return [acc]
}

reduce(useless, (a, b) =&gt; a+b)  // 15
</code></pre><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip函数用于合并给定的两个数组</p>
<pre><code>const zip = (leftArr, rightArr, fn) =&gt; {
    let results = []
    for(let index = 0; index &lt; Math.min(leftArr.length, rightArr.length); index++){
        results.push(fn(leftArr[index], rightArr[index]))
    }
    return results
}

zip([1,2,3], [4,5,6], (x, y) =&gt; x + y)  // [5, 7, 9]    
</code></pre><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第5章     </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/04/15/functional3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/functional3/" itemprop="url">函数式编程（二）：高阶函数（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T22:24:25+08:00">2018-04-15</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>简言之，闭包就是一个内部函数。在另一个函数内部的函数，称为内部函数。</p>
<pre><code>function outer () {
    function inner () {}
}
</code></pre><p>这就是闭包。函数inner被称为闭包函数。</p>
<p>闭包有三个可访问的作用域</p>
<ul>
<li>在他自身声明之内声明的变量</li>
<li>对全局变量的访问</li>
<li>对外部函数变量的访问</li>
</ul>
<hr>
<pre><code>function outer () {
    function inner () {
        let a = 5
        console.log(a)
    }
    inner()
}
</code></pre><p><strong>当inner函数被调用的时候，控制台会输出5（闭包函数可以访问在他自身声明之内声明的变量）</strong></p>
<pre><code>let global = &apos;global&apos;

function outer () {
    function inner () {
        let a = 5
        console.log(global)
    }
    inner()
} 
</code></pre><p><strong>当inner函数被调用的时候，控制台会输出’global’（闭包函数可以访问全局变量）</strong></p>
<pre><code>let global = &apos;global&apos;

function outer () {
    let out = &apos;out&apos;
    function inner () {
        let a = 5
        console.log(out)
    }
    inner()
} 
</code></pre><p><strong>当inner函数被调用的时候，控制台会输出’out’</strong>    </p>
<h3 id="记住闭包生成的位置"><a href="#记住闭包生成的位置" class="headerlink" title="记住闭包生成的位置"></a>记住闭包生成的位置</h3><p>如下代码</p>
<pre><code>let fn = (arg) =&gt; {
    let outer = &apos;Visible&apos;
    let innerFn = () =&gt; {
        console.log(outer)
        console.log(arg)
    }

    return innerFn
}
</code></pre><p>innerFn对于fn来说，是一个闭包函数，并且fn被调用后返回了innerFn。</p>
<pre><code>let closureFn = fn(5)
closureFn() // Visible; 5   
</code></pre><p>fn被调用时，返回了innerFn，当innerFn被返回时，JavaScript执行引擎视innerFn为一个闭包，如上一小节所说，闭包有三个作用域层级。这三个作用域层级（arg，outer值将被设置到inner的作用域层级中）在innerFn返回时都被设置了！返回函数的引用存储在了closureFn中。如此，当closureFn通过作用域链被调用时就记住了arg、outer的值。  </p>
<h3 id="回顾sortBy函数"><a href="#回顾sortBy函数" class="headerlink" title="回顾sortBy函数"></a>回顾sortBy函数</h3><p>快速回顾一下上一篇中定义和使用的sortBy函数</p>
<pre><code>const sortBy = (property) =&gt; {
    return (a, b) =&gt; {
        let result = (a[property] &lt; b[property] ? -1 : (a[property] &gt; b[property]) ? 1 : 0)

        return result
    }
}
</code></pre><p>当以如下方式调用sortBy函数</p>
<pre><code>sortBy(&apos;firstname&apos;)
</code></pre><p>sortBy函数返回了一个接受两个参数的新函数</p>
<pre><code>(a, b) =&gt; (/* 实现 */)
</code></pre><p>这时返回的函数就能够访问property参数，所以就可以根据传入的property值写对应的逻辑</p>
<h2 id="真实的高阶函数"><a href="#真实的高阶函数" class="headerlink" title="真实的高阶函数"></a>真实的高阶函数</h2><h3 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h3><blockquote>
<p>tap函数是一个简单的函数，他将接受一个value并返回一个包含value的闭包函数，该函数将被执行</p>
</blockquote>
<pre><code>const tap = (value) =&gt; (fn) =&gt; (
    typeof(fn) === &apos;function&apos; &amp;&amp; fn(value),
    console.log(value)
)

tap(&apos;fun&apos;)((it) =&gt; console.log(&apos;vaule is: &apos;, it))
// value is  fun
// fun
</code></pre><h3 id="unary"><a href="#unary" class="headerlink" title="unary"></a>unary</h3><blockquote>
<p>unary接受一个给定多个参数的函数，并把它转换为一个只接受一个参数的函数</p>
</blockquote>
<p>有数组[‘1’, ‘2’, ‘3’]，我期望能够将数组中的每一项改为number，我们可以利用数组的map方法</p>
<pre><code>[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt)
// [1, NaN, NaN]
</code></pre><p>然而返回的并不是我们所期望，map函数参数中传入的函数接收两个参数，第一个是数组中的每一项，第二个该项的索引。parseInt函数接收两个参数，第一个是将要转化的字符串，第二个按照几进制转换，默认10进制。由此可见，当进行到数组的第二项，parseInt函数接收到的第一个参数是’2’,第二个参数是1，所以会返回NaN。</p>
<pre><code>const unary = (fn) =&gt; fn.length &lt;= 1 ? fn : (arg) =&gt; fn(arg)
</code></pre><p>unary函数接收一个函数为参数，如果这个函数接收的参数个数小于等于1什么都不做，否则返回一个新函数，他只接受一个参数arg</p>
<p>接下来我们可以通过unary函数再来完成上述任务</p>
<pre><code>[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(unary(parseInt)) 
// [1, 2, 3]
</code></pre><h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><blockquote>
<p>once函数的任务是只运行一次给定的函数</p>
</blockquote>
<pre><code>const once = (fn) =&gt; {
    let done = false

    return function (...args) {
        return done ? undefined : ((done = true), fn.apply(this, args))
    }
}    
</code></pre><p>下面我们来快速检测一下once函数</p>
<pre><code>const doPayment = once(() =&gt; console.log(&apos;doPayment is done!&apos;))

// 执行第一次
doPayment() // doPayment is done!
// 执行第二次
doPayment() // undefined  
</code></pre><h3 id="memoized"><a href="#memoized" class="headerlink" title="memoized"></a>memoized</h3><blockquote>
<p>memoized函数将已经计算过的结果存储起来，下次再有相同的计算时可以直接从内存中读取</p>
</blockquote>
<p>有以下阶乘函数</p>
<pre><code>let factorial = (n) =&gt; {
    if (n == 0) return 1

    return n * factorial(n - 1)
}
</code></pre><p>此处没有什么特别的，但有一个问题，为了计算3的阶乘，必须要先计算2的阶乘，为什么不能直接给出结果呢？</p>
<pre><code>const memoized = (fn) =&gt; {
    let lookupTable = {}

    return (arg) =&gt; lookupTable[arg] || (lookupTable[arg] = fn(arg))
} 
</code></pre><p>现在我们可以把factorial函数包裹进一个memoized函数来保留他的输出了</p>
<pre><code>let fastFactorial = memoized (factorial) 
</code></pre><p>现在调用 fastFactorial</p>
<pre><code>fastFactorial(5)
// 120
// lookupTable为 Object: {0: 1, 1: 1, 2: 2, 3: 6, 4: 24, 5: 120}

fastFactorial(3)
// 6 直接从lookupTable返回
</code></pre><p>以同样的方式运行，但是比之前会快很多。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第3章     </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/04/07/functional2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/functional2/" itemprop="url">函数式编程（二）：高阶函数（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T22:11:34+08:00">2018-04-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解数据"><a href="#理解数据" class="headerlink" title="理解数据"></a>理解数据</h2><h3 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h3><blockquote>
<p>当一门语言允许函数作为任何其他数据类型使用时，函数被称为<strong>一等公民（First Class Citizens）</strong></p>
</blockquote>
<p>简单的将，JS支持如下几种数据类型：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Object</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
</ul>
<p>而<strong>函数也可以作为JS的一种数据类型</strong>，我们可以把函数存储在变量中，像操作其他类型数据一样操作他，当一门语言允许函数作为任何其他数据类型使用时，函数被称为<strong>一等公民（First Class Citizens）</strong></p>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>把函数存储到一个变量中：</p>
<pre><code>let fn = () =&gt; {}
</code></pre><p>上述代码中，fn就是一个指向函数数据类型的变量，运行下面代码检测fn的类型</p>
<pre><code>typeof fn   //function
</code></pre><p>既然fn是函数的引用，那就可以这样调用他：<code>fn()</code></p>
<h3 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h3><p>将函数以参数的形式传入另一个函数中</p>
<pre><code>let tellType = (arg) =&gt; {
    console.log(typeof arg)
}
</code></pre><p>像tellType传入参数并看他的执行结果</p>
<pre><code>let fn = () =&gt; {
    console.log(&apos;I&apos;m a function&apos;)
}    

tellType(fn) // function
</code></pre><p>如上述代码所示，我们成功的打印出了fn的类型</p>
<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>既然函数也是JavaScript中的数据，就能把他们从其他函数中返回</p>
<pre><code>let crazy = () =&gt; String
crazy() // String() { [native code] }
</code></pre><p>调用crazy函数返回了一个String函数，他只返回了函数的引用，并没有执行。因此可以暂存返回函数的引用，并以如下方式调用</p>
<pre><code>let fn = crazy()
fn(&apos;HOC&apos;)   // HOC
</code></pre><p>或者</p>
<pre><code>crazy()(&apos;HOC&apos;)  // HOC
</code></pre><h2 id="抽象和高阶函数"><a href="#抽象和高阶函数" class="headerlink" title="抽象和高阶函数"></a>抽象和高阶函数</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。</p>
<h3 id="通过高阶函数实现抽象"><a href="#通过高阶函数实现抽象" class="headerlink" title="通过高阶函数实现抽象"></a>通过高阶函数实现抽象</h3><pre><code>const forEach = (arr, fn) =&gt; {
    for (let i = 0; i &lt; arr.length; i++){
        fn(arr[i])
    }
}  
</code></pre><p>上面的forEach函数抽象出了遍历数组的问题。使用API forEach的用户不需要理解forEach是如何实现遍历的，如此问题就被抽象出来了。</p>
<p>创建一个名为unless的函数，这是一个简单的函数，接收一个断言（值为true或false）。如果predicate为false，则调用fn</p>
<pre><code>const unless = (predicate, fn) =&gt; {
    if (!predicate) {
        fn()
    }
}
</code></pre><p>有了unless函数就可以编写一段简洁的代码来查找一个列表中的偶数</p>
<pre><code>forEach([1,2,3,4,5,6,7], (number) =&gt; {
    unless((number % 2), () =&gt; {
        console.log(number, &apos; is even&apos;)
    })
})

// 2 &apos; is even&apos;
// 4 &apos; is even&apos;
// 6 &apos; is even&apos;
</code></pre><p>上面的例子会从数组中获取偶数，如果要从0到100中获取偶数，该如何做呢？</p>
<p>定义一个times函数，times是一个简单的高阶函数，他接收一个数字，并根据调用者提供的次数调用传入的函数。</p>
<pre><code>const times = (times, fn) =&gt; {
    for (let i = 0; i &lt; times; i++){
        fn(i)
    }
}    
</code></pre><p>现在我们解决如何获取0到100中的偶数问题</p>
<pre><code>times(100, (n) =&gt; {
    unless((n % 2), () =&gt; {
        console.log(n, &apos;is even&apos;)
    })
})
</code></pre><p>我们将解题过程中的每一步都抽象了出来，使当前的函数只关心当前的工作，最后再以组合的形式得到了答案，其中过程清晰明了，于是有了简洁的代码</p>
<h2 id="真实的高阶函数"><a href="#真实的高阶函数" class="headerlink" title="真实的高阶函数"></a>真实的高阶函数</h2><h3 id="简单的高阶函数"><a href="#简单的高阶函数" class="headerlink" title="简单的高阶函数"></a>简单的高阶函数</h3><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><blockquote>
<p>every函数接收两个参数，一个数组和一个函数，他使用传入的函数检查数组中的所有元素是否为true</p>
</blockquote>
<pre><code>const every = (arr, fn) =&gt; {
    let result = true

    for (const value of arr) {
        result = result &amp;&amp; fn(value)
    }

    return result
}

every([NaN, NaN, NaN], isNaN)   // true
evert([NaN, NaN, 4], isNaN)     // false
</code></pre><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><blockquote>
<p>some函数与every函数类似，不同的是如果数组中有一个元素通过传入的函数返回true，some函数就返回true</p>
</blockquote>
<pre><code>const some = (arr, fn) =&gt; {
    let result = true

    for (const value of arr) {
        result = result || fn(value)
    }

    return result
} 

some([NaN, NaN, 4], isNaN)  // true
some([2, 3, 4], isNaN)  // false&apos;
</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort函数是JavaScript的Array原型的内置函数。假设我们需要 给一个水果列表排序</p>
<pre><code>let fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;]

fruit.sort()    // [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]
</code></pre><p>sort函数是一个高阶函数，他接收一个函数作为参数，该函数用于帮助sort函数决定排序逻辑。</p>
<pre><code>arr.sort([compareFunction])
</code></pre><p>compareFunction是可选的，如果compareFunction未提供，元素将被转化为字符串并按Unicode编码点顺序排列。<br>在编写compareFunction之前，让我们看一下他实际应该实现什么</p>
<pre><code>function compare(a, b) {
    if (根据某种排序标准a小于b) {
        return -1
    }

    if (根据某种排序标准a大于b) {
        return 1
    }

    // a一定等于b
    return 0
}    
</code></pre><p>假设我们有如下数据</p>
<pre><code>let people = [
    { firstname: &apos;aaFirstName&apos;, lastname: &apos;ccLastName&apos; },
    { firstname: &apos;ccFirstName&apos;, lastname: &apos;aaLastName&apos; },
    { firstname: &apos;bbFirstName&apos;, lastname: &apos;bbLastName&apos; }
]
</code></pre><p>现在需要使用firstname键对数据进行排序</p>
<pre><code>pepple.sort((a, b) =&gt; {return (a.firstname &lt; b.firstname) ? -1 : (a.firstname &gt; b.firstname) ? 1 : 0})
</code></pre><p>如果现在要根据lastname排序</p>
<pre><code>pepple.sort((a, b) =&gt; {return (a.lastname &lt; b.lastname) ? -1 : (a.lastname &gt; b.lastname) ? 1 : 0})
</code></pre><p>知道了compareFunction的算法，我们能做的更好吗？上面的例子中可以看到，我们几乎用重复的代码编写了两个函数去比较firstname和lastname。我们能把上面的逻辑抽象到一个函数中去吗？</p>
<pre><code>const sortBy = (property) =&gt; {
    return (a, b) =&gt; {
        let result = (a[property] &lt; b[property] ? -1 : (a[property] &gt; b[property]) ? 1 : 0)

        return result
    }
}   
</code></pre><p>sortBy函数接收一个名为property的参数，并返回一个接收两个参数的新函数，现在我们可以这样调用</p>
<pre><code>people.sort(sortBy(&apos;firstname&apos;))
people.sort(sortBy(&apos;lastname&apos;))
</code></pre><p>sort函数接收被sortBy函数返回的compareFunction，我们再次抽象出了compareFunction背后的逻辑，使得用户专注与真正的需求。那么持有property参数值的返回函数是如何得来的？下一篇中我们将讨论这个问题。    </p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《JavaScript ES6 函数编程入门经典》第3章 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/03/11/functional1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/functional1/" itemprop="url">函数式编程(一)：简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T22:56:21+08:00">2018-03-11</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先来看下数学上的函数：</p>
<blockquote>
<p>f(x)=y</p>
</blockquote>
<p>可以解读为: <strong>函数f，以x作为参数，并返回输出y</strong>；这个简单的定义包含了几个点：</p>
<ul>
<li>函数必须总是接收一个参数</li>
<li>函数必须总是返回一个值</li>
<li>函数应该依据接收到的参数而不是外部环境运行</li>
<li>对于一个给定的X，只会输出唯一的一个Y</li>
</ul>
<p>有了数学上的函数定义，可以理解出程序上的定义：<strong>函数式编程是一种<a href="https://baike.baidu.com/item/%E8%8C%83%E5%BC%8F/22773" target="_blank" rel="noopener">范式</a>，我们能够以此创建仅依赖数据就可以完成自身逻辑的函数（函数不会改变任何外部环境的变量）</strong></p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let percentValue = 5</span><br><span class="line">let calculateTax = (value) =&gt; value/100 * (100 + percentValue)</span><br></pre></td></tr></table></figure>
<p>上面代码中，calculateTax返回一个经过计算的数值，理论上讲，该段代码无任何异议；但该函数在数学意义上就不能称之为一个真正的函数，因为他的执行依赖了一个外部环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let calculateTax = (value, percentValue) =&gt; value/100 * (100 + percentValue)</span><br></pre></td></tr></table></figure>
<p>上面这段代码则可以被成为一个真正的函数了。我们做了什么 -&gt; 在函数内部消除了对外部环境的访问。稍后会介绍这么做的好处。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><blockquote>
<p>引用透明性: 相同的输入都会返回相同的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let identity = (i) =&gt; i</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个函数 <code>identity</code>，他将传入的值作为输出，没有任何依赖的外部环境，该函数满足了引用透明性条件。现在假设该函数被用于其他函数调用之处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(4, 5) + identity(1)</span><br></pre></td></tr></table></figure>
<p>根据引用透明性原则，我们可以把上面的函数转化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(4, 5) + 1</span><br></pre></td></tr></table></figure>
<p>这个过程被称为<strong>替换模型（Substitution Model）</strong></p>
<h3 id="声名式"><a href="#声名式" class="headerlink" title="声名式"></a>声名式</h3><p>给定一个数组，我想分别打印出数组的每一项，有如下两段代码：</p>
<p>A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">arr.forEach((item) =&gt; console.log(item))</span><br></pre></td></tr></table></figure>
<p> 上面两段代码都可以完成我们规定的任务，区别在于：</p>
<ul>
<li>代码A是命令式的</li>
<li>代码B是声名式的</li>
</ul>
<p>回顾一下我们的任务： <strong>打印出数组中的每一项</strong></p>
<ul>
<li>代码A中，我们精确的告诉了程序改怎么做：我们用数组长度的索引编写了一个for循环，然后再打印出数组的每一项，这并不是任务的初衷，而是在<code>精确的告知程序该怎么做</code>，我们称这种解决方案为<strong>命令式</strong></li>
<li>代码B中，程序准确的执行了我们的任务：<strong>打印出数组中的每一项</strong>，这种<code>告知程序做什么的</code>解决方案，我们称之为<strong>声名式</strong></li>
</ul>
<blockquote>
<p>命令式 -&gt; 怎么做<br>声名式 -&gt; 做什么</p>
</blockquote>
<h2 id="函数式编程带来的好处"><a href="#函数式编程带来的好处" class="headerlink" title="函数式编程带来的好处"></a>函数式编程带来的好处</h2><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><blockquote>
<p>纯函数是对给定的输入返回相同的输出的函数</p>
</blockquote>
<pre><code>let double = (value) =&gt; value * 2
</code></pre><p>上面的double函数就是一个纯函数，因为给他一个输入，他总是能返回相同的输出</p>
<h3 id="并发代码"><a href="#并发代码" class="headerlink" title="并发代码"></a>并发代码</h3><blockquote>
<p>根据引用通明原则，我们可以同步的执行函数</p>
</blockquote>
<p>假设我们用JS中的WebWorker来并发的执行多任务，有以下代码</p>
<pre><code>let global = &apos;something&apos;

let function1 = (input) =&gt; {
    // 处理input
    // 改变global
    global = &apos;somethingElse&apos;
}

let function2 = () =&gt; {
    if (global === &apos;something&apos;) {
        // 业务逻辑
    }
}
</code></pre><p>如果我们要并发的执行function1和function2，会因为先后顺序等因素得到不同结果，现在把这些函数改为纯函数</p>
<pre><code>let function1 = (input, global) =&gt; {
    // 处理input
    // 改变global
    global = &apos;somethingElse&apos;
}

let function2 = (global) =&gt; {
    if (global === &apos;something&apos;) {
        // 业务逻辑
    }
}
</code></pre><p>此处我们移动了global变量，把他作为两个函数的参数，使他们变为纯函数。现在我们可以并发的执行两个函数了，不会带来任何问题。</p>
<h3 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h3><blockquote>
<p>既然纯函数总是为给定的输入返回相同的输出，那么我们就能够缓存函数的输出</p>
</blockquote>
<p>假设有如下做耗时计算的函数：</p>
<pre><code>let longRunningFunction = (ip) =&gt; { // do long running tasks and return }
</code></pre><p><strong>如果longRunningFunction是纯函数</strong>，我们知道相同的输入那么他总会返回相同输出，那么我们能不能将函数的结果作为下一个函数的调用呢？</p>
<p>假设我们有一个对象，他存储了longRunningFunction的所有调用结果：</p>
<pre><code>let longRunningFnBookKeeper = {
    2: 3,
    4: 5,
    ...
}
</code></pre><p>现在我们在调用原始函数之前检查key是否在longRunningFnBookKeeper中</p>
<pre><code>let longRunningFnBookKeeper = {
    2: 3,
    4: 5,
    ...
}

// 检查key是否在longRunningFnBookKeeper中
// 如果在返回返回结果否则更新对象
longRunningFnBookKeeper.hasOwnPrototype(ip) ? 
    longRunningFnBookKeeper.hasOwnPrototype[ip] :
    longRunningFnBookKeeper.hasOwnPrototype = longRunningFunction(ip)
</code></pre><p>另一个栗子：</p>
<pre><code>let factorial (n) {
    if (n === 1) return 1
    return n * factorial(n - 1)
}
</code></pre><p>上面的代码是一个阶乘函数，计算n的阶乘，要保存n个调用记录，复杂度O(n)</p>
<img src="/2018/03/11/functional1/1-1.png">
<p>通过缓存的方式将中个阶乘函数改写</p>
<pre><code>let factorial (n, result) {
    if (n === 1) return result
    return factorial(n - 1, n * result)
}
</code></pre><img src="/2018/03/11/functional1/1-2.png">
<p>上面的代码，我们将上一次的计算结果缓存，复杂度O(1)  </p>
<h3 id="管道与组合"><a href="#管道与组合" class="headerlink" title="管道与组合"></a>管道与组合</h3><p>在UNIX和LINUX的平台中有许多用于日常任务的命令</p>
<pre><code>ps -ef | grep nginx
</code></pre><p>上面的命令用于查询系统中的nginx信息，这就是一个典型的组合方式。</p>
<img src="/2018/03/11/functional1/1-3.png">
<p>上图中，X和Y之间的变形关系是函数f，Y和Z的变形关系是g，那么X和Z之间的关系，就是g和f的组合函数： </p>
<pre><code>g(f(x))
</code></pre><p>另一种方式</p>
<pre><code>foo(x).compose(f).compose(g)
</code></pre><p>将值通过链式调用的方式逐级传递</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html</a></li>
<li>《JavaScript ES6 函数编程入门经典》第1章 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lvvlan.github.io/2018/01/28/my-new-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemonleon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonleon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/28/my-new-post/" itemprop="url">my new post</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T17:16:54+08:00">2018-01-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="这是一篇测试文章"><a href="#这是一篇测试文章" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h4><blockquote class="blockquote-center"><p>Talk is cheap, show me your code.</p>
</blockquote>
<blockquote><p>感时花溅泪，恨别鸟惊心。</p>
<footer><strong>杜甫</strong><cite>《春望》</cite></footer></blockquote>
<p><br></p>
<div class="note primary"><p></p><h3>title</h3><br>content<p></p></div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/1.jpeg"
                alt="lemonleon" />
            
              <p class="site-author-name" itemprop="name">lemonleon</p>
              <p class="site-description motion-element" itemprop="description">码农/猫奴/瞎烧友/伪影迷</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lvvlan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lemonleon</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.2</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
